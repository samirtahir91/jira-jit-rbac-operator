
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">jira-jit-rbac-operator/internal/controller/jitrequest_controller.go (69.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "strings"
        "time"

        jira "github.com/ctreminiom/go-atlassian/v2/jira/v2"
        "github.com/ctreminiom/go-atlassian/v2/pkg/infra/models"
        "github.com/go-logr/logr"

        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder" // Required for Watching
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        justintimev1 "jira-jit-rbac-operator/api/v1"
        "jira-jit-rbac-operator/internal/config"
)

var (
        OperatorNamespace = os.Getenv("OPERATOR_NAMESPACE")
)

const (
        StatusRejected        = "Rejected"
        StatusPreApproved     = "Pre-Approved"
        StatusSucceeded       = "Succeeded"
        EventValidationFailed = "ValidationFailed"
)

// JitRequestReconciler reconciles a JitRequest object
type JitRequestReconciler struct {
        JiraClient *jira.Client
        client.Client
        Scheme   *runtime.Scheme
        Recorder record.EventRecorder
}

// Reconcile loop
func (r *JitRequestReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        l := log.FromContext(ctx)

        // Fetch the JitRequest instance
        jitRequest, err := r.fetchJitRequest(ctx, req.NamespacedName)
        if err != nil </span><span class="cov8" title="1">{
                return r.handleFetchError(ctx, l, err, jitRequest)
        }</span>

        // Fetch operator config
        <span class="cov8" title="1">operatorConfig, err := r.readConfigFromFile(config.ConfigCacheFilePath, config.ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">jiraWorkflowApproveStatus := operatorConfig.JiraWorkflowApproveStatus
        rejectedTransitionID := operatorConfig.RejectedTransitionID
        allowedClusterRoles := operatorConfig.AllowedClusterRoles
        jiraProject := operatorConfig.JiraProject
        jiraIssueType := operatorConfig.JiraIssueType
        approvedTransitionID := operatorConfig.ApprovedTransitionID
        customFieldsConfig := operatorConfig.CustomFields
        requiredFieldsConfig := operatorConfig.RequiredFields
        ticketLabels := operatorConfig.Labels
        targetEnvironment := operatorConfig.Environment
        additionalComments := operatorConfig.AdditionalCommentText

        l.Info("Got JitRequest", "Requestor", jitRequest.Spec.Reporter, "Role", jitRequest.Spec.ClusterRole, "Namespace", strings.Join(jitRequest.Spec.Namespaces, ", "))

        // Handle JitRequest based on its status
        switch jitRequest.Status.State </span>{
        case StatusRejected:<span class="cov8" title="1">
                return r.handleRejected(ctx, l, jitRequest, rejectedTransitionID)</span>
        case "":<span class="cov8" title="1">
                return r.handleNewRequest(ctx, l, jitRequest, allowedClusterRoles, jiraProject, jiraIssueType, customFieldsConfig, requiredFieldsConfig, ticketLabels, targetEnvironment, additionalComments)</span>
        case StatusPreApproved:<span class="cov8" title="1">
                return r.handlePreApproved(ctx, l, jitRequest, approvedTransitionID, jiraWorkflowApproveStatus)</span>
        case StatusSucceeded:<span class="cov8" title="1">
                return r.handleCleaup(ctx, l, jitRequest)</span>
        default:<span class="cov0" title="0">
                return r.handleCleaup(ctx, l, jitRequest)</span>
        }
}

// Fetch a JitRequest
func (r *JitRequestReconciler) fetchJitRequest(ctx context.Context, namespacedName types.NamespacedName) (*justintimev1.JitRequest, error) <span class="cov8" title="1">{
        jitRequest := &amp;justintimev1.JitRequest{}
        err := r.Get(ctx, namespacedName, jitRequest)
        return jitRequest, err
}</span>

// Cleanup owned objects (rolebindings) on deleted JitRequests
func (r *JitRequestReconciler) handleFetchError(
        ctx context.Context,
        l logr.Logger,
        err error,
        jitRequest *justintimev1.JitRequest,
) (ctrl.Result, error) <span class="cov8" title="1">{
        if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                l.Info("JitRequest resource not found. Deleting managed objects.")
                if err := r.deleteOwnedObjects(ctx, jitRequest); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }
        <span class="cov0" title="0">l.Error(err, "failed to get JitRequest")
        return ctrl.Result{}, err</span>
}

// Read operator configuration from config file
func (r *JitRequestReconciler) readConfigFromFile(filePath string, fileName string) (*justintimev1.JustInTimeConfigSpec, error) <span class="cov8" title="1">{
        // common lock for concurrent reads
        config.ConfigLock.RLock()
        defer config.ConfigLock.RUnlock()

        data, err := os.ReadFile(fmt.Sprintf("%s/%s", filePath, fileName))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read configuration file: %w", err)
        }</span>

        <span class="cov8" title="1">var config justintimev1.JustInTimeConfigSpec
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse configuration file: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// Reject Jira ticket and delete JitRequest
func (r *JitRequestReconciler) handleRejected(
        ctx context.Context,
        l logr.Logger,
        jitRequest *justintimev1.JitRequest,
        rejectedTransitionID string,
) (ctrl.Result, error) <span class="cov8" title="1">{
        // Reject jira ticket
        if jitRequest.Status.JiraTicket != "Skipped" </span><span class="cov8" title="1">{
                if err := r.rejectJiraTicket(ctx, jitRequest, rejectedTransitionID); err != nil </span><span class="cov0" title="0">{
                        l.Error(err, "failed to reject jira ticket")
                        return ctrl.Result{}, err
                }</span>
        }
        // Delete JitRequest
        <span class="cov8" title="1">if err := r.deleteJitRequest(ctx, jitRequest); err != nil </span><span class="cov0" title="0">{
                l.Error(err, "failed to delete JitRequest")
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// Validate namespace(s) have namespaceLabels
func (r *JitRequestReconciler) validateNamespaceLabels(ctx context.Context, jitRequest *justintimev1.JitRequest) (string, error) <span class="cov8" title="1">{
        for _, namespace := range jitRequest.Spec.Namespaces </span><span class="cov8" title="1">{
                ns := &amp;corev1.Namespace{}
                err := r.Get(ctx, client.ObjectKey{Name: namespace}, ns)
                if err != nil </span><span class="cov8" title="1">{
                        return namespace, fmt.Errorf("failed to get namespace %s: %v", namespace, err)
                }</span>

                <span class="cov8" title="1">for key, value := range jitRequest.Spec.NamespaceLabels </span><span class="cov8" title="1">{
                        if ns.Labels[key] != value </span><span class="cov8" title="1">{
                                return namespace, fmt.Errorf("namespace %s does not have the label %s=%s", namespace, key, value)
                        }</span>
                }
        }
        <span class="cov8" title="1">return "", nil</span>
}

// Create new Jira ticket for new JitRequests, validate config
func (r *JitRequestReconciler) handleNewRequest(
        ctx context.Context,
        l logr.Logger,
        jitRequest *justintimev1.JitRequest,
        allowedClusterRoles []string,
        jiraProject,
        jiraIssueType string,
        customFieldsConfig map[string]justintimev1.CustomFieldSettings,
        requiredFieldsConfig *justintimev1.RequiredFieldsSpec,
        ticketLabels []string,
        targetEnvironment *justintimev1.EnvironmentSpec,
        additionalComments string,
) (ctrl.Result, error) <span class="cov8" title="1">{
        jiraIssueKey, err := r.createJiraTicket(ctx, jitRequest, jiraProject, jiraIssueType, customFieldsConfig, requiredFieldsConfig, ticketLabels, targetEnvironment)
        if err != nil </span><span class="cov0" title="0">{
                l.Error(err, "failed to createJiraTicket")
                return ctrl.Result{}, err
        }</span>

        // Return if missing jira field
        <span class="cov8" title="1">if jiraIssueKey == "Skipped" </span><span class="cov0" title="0">{
                return ctrl.Result{}, nil
        }</span>

        // check cluster role is allowed
        <span class="cov8" title="1">if !contains(allowedClusterRoles, jitRequest.Spec.ClusterRole) </span><span class="cov8" title="1">{
                return r.rejectInvalidRole(ctx, l, jitRequest, jiraIssueKey)
        }</span>

        // check namespace labels match namespace(s)
        <span class="cov8" title="1">ns, err := r.validateNamespaceLabels(ctx, jitRequest)
        if err != nil </span><span class="cov8" title="1">{
                return r.rejectInvalidNamespace(ctx, l, jitRequest, jiraIssueKey, ns, err.Error())
        }</span>

        <span class="cov8" title="1">return r.preApproveRequest(ctx, l, jitRequest, jiraIssueKey, additionalComments)</span>
}

// Reject an invalid namespace
func (r *JitRequestReconciler) rejectInvalidNamespace(
        ctx context.Context,
        l logr.Logger,
        jitRequest *justintimev1.JitRequest,
        jiraIssueKey, namespace, err string,
) (ctrl.Result, error) <span class="cov8" title="1">{
        errorMsg := fmt.Sprintf("Namespace %s is not validated | Error: %s", namespace, err)
        r.raiseEvent(jitRequest, "Warning", EventValidationFailed, errorMsg)
        if err := r.updateStatus(ctx, jitRequest, StatusRejected, errorMsg, jiraIssueKey, 3); err != nil </span><span class="cov0" title="0">{
                l.Error(err, "failed to update status to Rejected")
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// Reject an invalid cluster role
func (r *JitRequestReconciler) rejectInvalidRole(
        ctx context.Context,
        l logr.Logger,
        jitRequest *justintimev1.JitRequest,
        jiraIssueKey string,
) (ctrl.Result, error) <span class="cov8" title="1">{
        errorMsg := fmt.Sprintf("ClusterRole '%s' is not allowed", jitRequest.Spec.ClusterRole)
        r.raiseEvent(jitRequest, "Warning", EventValidationFailed, errorMsg)
        if err := r.updateStatus(ctx, jitRequest, StatusRejected, errorMsg, jiraIssueKey, 3); err != nil </span><span class="cov0" title="0">{
                l.Error(err, "failed to update status to Rejected")
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// Pre-approve the JitRequest, update the Jira ticke and queue for start time
func (r *JitRequestReconciler) preApproveRequest(
        ctx context.Context,
        l logr.Logger,
        jitRequest *justintimev1.JitRequest,
        jiraIssueKey, additionalComments string,
) (ctrl.Result, error) <span class="cov8" title="1">{
        startTime := jitRequest.Spec.StartTime.Time

        if startTime.After(time.Now()) </span><span class="cov8" title="1">{

                // update status and event
                r.raiseEvent(jitRequest, "Normal", StatusPreApproved, fmt.Sprintf("ClusterRole '%s' is allowed\nJira: %s", jitRequest.Spec.ClusterRole, jiraIssueKey))
                // status
                jitRequestStatusMsg := "Pre-approval - Access will be granted at start time pending human approval(s)"
                if err := r.updateStatus(ctx, jitRequest, StatusPreApproved, jitRequestStatusMsg, jiraIssueKey, 3); err != nil </span><span class="cov0" title="0">{
                        l.Error(err, "failed to update status to Pre-Approved")
                        return ctrl.Result{}, err
                }</span>

                // build comment
                <span class="cov8" title="1">jiraMessage := fmt.Sprintf("{color:#00875a}*%s*{color}", jitRequestStatusMsg)
                namespaces := strings.Join(jitRequest.Spec.Namespaces, "\n")
                comment := jiraMessage + "\n|*Namespace(s)*|" + namespaces + "|\n|*User*|" + jitRequest.Spec.Reporter + "|"

                // check if additionalUsers defined and add to comment
                additionalUsers := jitRequest.Spec.AdditionUserEmails
                if len(additionalUsers) &gt; 0 </span><span class="cov0" title="0">{
                        additionalUsersStr := strings.Join(additionalUsers, "\n")
                        comment += "\n|*Additional Users*|" + additionalUsersStr + "|"
                }</span>

                // add additional comments if exists
                <span class="cov8" title="1">if additionalComments != "" </span><span class="cov8" title="1">{
                        comment += "\n\n*Additional Info:*\n" + additionalComments
                }</span>

                // add comment
                <span class="cov8" title="1">if err := r.updateJiraTicket(ctx, jiraIssueKey, comment); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                // requeue for start time
                <span class="cov8" title="1">delay := time.Until(startTime)
                l.Info("Start time not reached, requeuing", "requeueAfter", delay)
                return ctrl.Result{RequeueAfter: delay}, nil</span>
        }

        // invalid start time, reject
        <span class="cov8" title="1">errMsg := fmt.Errorf("start time %s must be after current time", jitRequest.Spec.StartTime.Time)
        r.raiseEvent(jitRequest, "Warning", EventValidationFailed, errMsg.Error())
        if err := r.updateStatus(ctx, jitRequest, StatusRejected, errMsg.Error(), jiraIssueKey, 3); err != nil </span><span class="cov0" title="0">{
                l.Error(err, "failed to update status to Rejected")
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">l.Error(errMsg, "start time validation failed")
        return ctrl.Result{}, nil</span>
}

// Create the rolebinding for approved JitRequests if the Jira is approved
func (r *JitRequestReconciler) handlePreApproved(
        ctx context.Context,
        l logr.Logger,
        jitRequest *justintimev1.JitRequest,
        approvedTransitionID, jiraWorkflowApproveStatus string,
) (ctrl.Result, error) <span class="cov8" title="1">{
        // check if needs to be re-queued
        startTime := jitRequest.Spec.StartTime.Time
        if startTime.After(time.Now()) </span><span class="cov0" title="0">{
                // requeue for start time
                delay := time.Until(startTime)
                l.Info("Start time not reached, requeuing", "requeueAfter", delay)
                return ctrl.Result{RequeueAfter: delay}, nil
        }</span>

        <span class="cov8" title="1">jiraTicket := jitRequest.Status.JiraTicket
        if err := r.getJiraApproval(ctx, jitRequest, jiraWorkflowApproveStatus); err != nil </span><span class="cov8" title="1">{
                l.Error(err, StatusRejected, "jira ticket", jiraTicket)
                r.raiseEvent(jitRequest, "Warning", "JiraNotApproved", fmt.Sprintf("Error: %s", err))
                if err := r.updateStatus(ctx, jitRequest, StatusRejected, "Jira ticket has not been approved", jiraTicket, 3); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">l.Info("Creating role binding")
        if err := r.createRoleBinding(ctx, jitRequest); err != nil </span><span class="cov0" title="0">{
                l.Error(err, "failed to create rbac for JIT request")
                r.raiseEvent(jitRequest, "Warning", "FailedRBAC", fmt.Sprintf("Error: %s", err))
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">if err := r.updateStatus(ctx, jitRequest, StatusSucceeded, "Access granted until end time", jiraTicket, 3); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">if err := r.completeJiraTicket(ctx, jitRequest, approvedTransitionID); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Queue for deletion at end time
        <span class="cov8" title="1">return r.handleCleaup(ctx, l, jitRequest)</span>
}

// Handle and queue succeeded and unknown JitRequests for deletion
func (r *JitRequestReconciler) handleCleaup(ctx context.Context, l logr.Logger, jitRequest *justintimev1.JitRequest) (ctrl.Result, error) <span class="cov8" title="1">{
        endTime := jitRequest.Spec.EndTime.Time
        if endTime.After(time.Now()) </span><span class="cov8" title="1">{
                delay := time.Until(endTime)
                l.Info("End time not reached, requeuing", "requeueAfter", delay)
                return ctrl.Result{RequeueAfter: delay}, nil
        }</span>

        <span class="cov8" title="1">l.Info("End time reached, deleting JitRequest")
        if err := r.deleteJitRequest(ctx, jitRequest); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// Update jira with comment
func (r *JitRequestReconciler) updateJiraTicket(ctx context.Context, jiraTicket, comment string) error <span class="cov8" title="1">{
        l := log.FromContext(ctx)

        l.Info("Updating Jira ticket", "jiraTicket", jiraTicket)

        // Add a comment to the Jira issue
        payload := &amp;models.CommentPayloadSchemeV2{
                Body: comment,
        }
        _, response, err := r.JiraClient.Issue.Comment.Add(context.Background(), jiraTicket, payload, nil)
        if err != nil </span><span class="cov0" title="0">{
                if response != nil </span><span class="cov0" title="0">{
                        body := response.Bytes.String()
                        l.Error(err, "failed to add comment to jira ticket", "jiraTicket", jiraTicket, "response", body)
                }</span> else<span class="cov0" title="0"> {
                        l.Error(err, "failed to add comment to jira ticket", "jiraTicket", jiraTicket, "response", "nil response")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Complete jira with comment
func (r *JitRequestReconciler) completeJiraTicket(ctx context.Context, jitRequest *justintimev1.JitRequest, approvedTransitionID string) error <span class="cov8" title="1">{
        l := log.FromContext(ctx)

        // Add a comment to the Jira issue
        jiraTicket := jitRequest.Status.JiraTicket
        comment := fmt.Sprintf("{color:#00875a}*Completed - %s*{color}", jitRequest.Status.Message)
        l.Info("Compelting Jira ticket", "jiraTicket", jiraTicket)
        if err := r.updateJiraTicket(ctx, jiraTicket, comment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Complete ticket
        <span class="cov8" title="1">options := &amp;models.IssueMoveOptionsV2{
                Fields: &amp;models.IssueSchemeV2{
                        Fields: &amp;models.IssueFieldsSchemeV2{
                                Resolution: &amp;models.ResolutionScheme{},
                        },
                },
        }
        response, err := r.JiraClient.Issue.Move(context.Background(), jiraTicket, approvedTransitionID, options)
        if err != nil </span><span class="cov0" title="0">{
                body := response.Bytes.String()
                l.Error(err, "failed to transition jira ticket to completed", "response", body)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Check Jira ticket is approved
func (r *JitRequestReconciler) getJiraApproval(ctx context.Context, jitRequest *justintimev1.JitRequest, jiraWorkflowApproveStatus string) error <span class="cov8" title="1">{
        l := log.FromContext(ctx)
        l.Info("Checking Jira ticket approval", "jit request", jitRequest)

        jiraIssueKey := jitRequest.Status.JiraTicket

        // Fetch the Jira issue details
        issue, response, err := r.JiraClient.Issue.Get(ctx, jiraIssueKey, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                body := response.Bytes.String()
                l.Error(err, "failed to fetch Jira ticket details", "jiraTicket", jiraIssueKey, "response", body)
                return err
        }</span>

        // Check if the issue status is Approved
        <span class="cov8" title="1">if issue.Fields.Status.Name == jiraWorkflowApproveStatus </span><span class="cov8" title="1">{
                l.Info("Jira ticket is approved", "jiraTicket", jiraIssueKey)
                return nil
        }</span>

        <span class="cov8" title="1">return fmt.Errorf("failed on jira approval")</span>
}

// Get and return account ID for a Jira user by email - assumes single email per user and gets 1st result
func (r *JitRequestReconciler) getNameByEmail(email string) (string, error) <span class="cov8" title="1">{

        type User struct {
                Name string `json:"name"`
        }

        // RAW endpoint
        apiEndpoint := fmt.Sprintf("rest/api/2/user/search?username=%s", email)
        request, err := r.JiraClient.NewRequest(context.Background(), http.MethodGet, apiEndpoint, "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to find account name for reporter email: %w", err)
        }</span>

        <span class="cov8" title="1">var users []User
        response, err := r.JiraClient.Call(request, &amp;users)
        if err != nil </span><span class="cov0" title="0">{
                body := response.Bytes.String()
                return "", fmt.Errorf("failed to find account name for reporter email: %w, response: %s", err, body)
        }</span>

        // check if any users were found
        <span class="cov8" title="1">if len(users) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no users found with email: %s", email)
        }</span>

        // get the account name
        <span class="cov8" title="1">accountId := users[0].Name
        return accountId, nil</span>
}

// Helper function for createJiraTicket to build custom fields in jira ticket payload
func addCustomField(ctx context.Context, customFields *models.CustomFields, fieldType, jiraCustomField, value string) <span class="cov8" title="1">{
        l := log.FromContext(ctx)

        switch fieldType </span>{
        case "text", "date":<span class="cov8" title="1">
                if err := customFields.Text(jiraCustomField, value); err != nil </span><span class="cov0" title="0">{
                        l.Error(err, "failed to add custom field", "field", jiraCustomField)
                }</span>
        case "select":<span class="cov0" title="0">
                if err := customFields.Select(jiraCustomField, value); err != nil </span><span class="cov0" title="0">{
                        l.Error(err, "failed to add custom field", "field", jiraCustomField)
                }</span>
        case "user":<span class="cov8" title="1">
                userField := map[string]interface{}{
                        "name": value,
                }
                if err := customFields.Raw(jiraCustomField, userField); err != nil </span><span class="cov0" title="0">{
                        l.Error(err, "failed to add custom field", "field", jiraCustomField)
                }</span>
        default:<span class="cov0" title="0">
                l.Error(fmt.Errorf("unknown custom field type"), jiraCustomField, "type", fieldType)</span>
        }
}

// Create a jira ticket for a JitRequest
func (r *JitRequestReconciler) createJiraTicket(
        ctx context.Context,
        jitRequest *justintimev1.JitRequest,
        jiraProject,
        jiraIssueType string,
        customFieldsConfig map[string]justintimev1.CustomFieldSettings,
        requiredFieldsConfig *justintimev1.RequiredFieldsSpec,
        ticketLabels []string,
        targetEnvironment *justintimev1.EnvironmentSpec,
) (string, error) <span class="cov8" title="1">{
        l := log.FromContext(ctx)

        l.Info("Creating Jira ticket", "jiraTicket", jitRequest)

        customFields := models.CustomFields{}

        // Add custom fields from JustInTimeConfig spec
        for fieldName, settings := range customFieldsConfig </span><span class="cov8" title="1">{
                value, exists := jitRequest.Spec.JiraFields[fieldName]
                if !exists </span><span class="cov0" title="0">{
                        // missing field, reject
                        errMsg := fmt.Errorf("missing custom field: %s", fieldName)
                        if err := r.updateStatus(ctx, jitRequest, StatusRejected, errMsg.Error(), "Skipped", 3); err != nil </span><span class="cov0" title="0">{
                                l.Error(err, "failed to update status to Rejected")
                                return "Skipped", nil
                        }</span>
                }
                <span class="cov8" title="1">addCustomField(ctx, &amp;customFields, settings.Type, settings.JiraCustomField, value)</span>
        }

        // Add required fields for StartTime, EndTime, ClusterRole
        <span class="cov8" title="1">requiredFields := map[string]string{
                "StartTime":   jitRequest.Spec.StartTime.Format("2006-01-02T15:04:05.000-0700"),
                "EndTime":     jitRequest.Spec.EndTime.Format("2006-01-02T15:04:05.000-0700"),
                "ClusterRole": jitRequest.Spec.ClusterRole,
        }

        for fieldName, value := range requiredFields </span><span class="cov8" title="1">{
                var settings justintimev1.CustomFieldSettings
                switch fieldName </span>{
                case "StartTime":<span class="cov8" title="1">
                        settings = requiredFieldsConfig.StartTime</span>
                case "EndTime":<span class="cov8" title="1">
                        settings = requiredFieldsConfig.EndTime</span>
                case "ClusterRole":<span class="cov8" title="1">
                        settings = requiredFieldsConfig.ClusterRole</span>
                default:<span class="cov0" title="0">
                        l.Error(fmt.Errorf("unknown required field"), "field", fieldName)
                        continue</span>
                }
                <span class="cov8" title="1">addCustomField(ctx, &amp;customFields, settings.Type, settings.JiraCustomField, value)</span>
        }

        // Get Jira account ID from reporter email
        <span class="cov8" title="1">reporterAccountName, err := r.getNameByEmail(jitRequest.Spec.Reporter)
        if err != nil </span><span class="cov0" title="0">{
                l.Error(err, "failed to create Jira ticket")
                return "", err
        }</span>

        <span class="cov8" title="1">targetCluster := targetEnvironment.Cluster
        targetEnv := targetEnvironment.Environment
        combinedLabels := append(
                ticketLabels,
                "jira-jit-rbac-operator",
                "automated_jit_request",
                targetCluster,
                targetEnv,
        )

        // payload for new jira ticket
        payload := models.IssueSchemeV2{
                Fields: &amp;models.IssueFieldsSchemeV2{
                        Summary: fmt.Sprintf("Automated JIT request for %s", jitRequest.Spec.Reporter),
                        Project: &amp;models.ProjectScheme{
                                Key: jiraProject,
                        },
                        IssueType: &amp;models.IssueTypeScheme{
                                Name: jiraIssueType,
                        },
                        // Set reporter as per userID
                        Reporter: &amp;models.UserScheme{
                                Name: reporterAccountName,
                        },
                        Labels: combinedLabels,
                },
        }

        // Debug payload and customFields
        // l.Info("Jira Issue Payload", "payload", payload)
        // l.Info("Custom Fields Data", "customFields", customFields)

        createdIssue, response, err := r.JiraClient.Issue.Create(context.Background(), &amp;payload, &amp;customFields)
        if err != nil </span><span class="cov0" title="0">{
                body := response.Bytes.String()
                l.Error(err, "failed to create Jira ticket", "response", body, "payload", payload, "customFields", customFields)
                return "", err
        }</span>

        <span class="cov8" title="1">l.Info("Jira ticket created successfully", "jiraTicket", createdIssue.Key)
        return createdIssue.Key, nil</span>
}

// Reject jira with comment
func (r *JitRequestReconciler) rejectJiraTicket(ctx context.Context, jitRequest *justintimev1.JitRequest, rejectedTransitionID string) error <span class="cov8" title="1">{
        l := log.FromContext(ctx)

        // Add a comment to the Jira issue
        jiraTicket := jitRequest.Status.JiraTicket
        comment := fmt.Sprintf("{color:#de350b}*Rejected - %s*{color}", jitRequest.Status.Message)
        l.Info("Rejecting Jira ticket", "jiraTicket", jiraTicket)
        if err := r.updateJiraTicket(ctx, jiraTicket, comment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // reject ticket
        <span class="cov8" title="1">options := &amp;models.IssueMoveOptionsV2{
                Fields: &amp;models.IssueSchemeV2{
                        Fields: &amp;models.IssueFieldsSchemeV2{
                                Resolution: &amp;models.ResolutionScheme{},
                        },
                },
        }
        response, err := r.JiraClient.Issue.Move(context.Background(), jiraTicket, rejectedTransitionID, options)
        if err != nil </span><span class="cov0" title="0">{
                body := response.Bytes.String()
                l.Error(err, "failed to transition jira ticket", "response", body)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete a JitRequest
func (r *JitRequestReconciler) deleteJitRequest(ctx context.Context, jitRequest *justintimev1.JitRequest) error <span class="cov8" title="1">{
        l := log.FromContext(ctx)
        if err := r.Client.Delete(ctx, jitRequest); err != nil </span><span class="cov0" title="0">{
                l.Error(err, "Failed to delete JitRequest")
                return err
        }</span>
        <span class="cov8" title="1">l.Info("Successfully deleted JitRequest", "name", jitRequest.Name)
        return nil</span>
}

// Raise event in operator namespace
func (r *JitRequestReconciler) raiseEvent(obj client.Object, eventType, reason, message string) <span class="cov8" title="1">{
        eventRef := &amp;corev1.ObjectReference{
                Kind:       obj.GetObjectKind().GroupVersionKind().Kind,
                APIVersion: obj.GetObjectKind().GroupVersionKind().GroupVersion().String(),
                Name:       obj.GetName(),
                Namespace:  OperatorNamespace,
                UID:        obj.GetUID(),
        }

        r.Recorder.Event(eventRef, eventType, reason, message)
}</span>

// checks if a string is present in a slice.
func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Delete rolebinding in case of k8s GC failed to delete
func (r *JitRequestReconciler) deleteOwnedObjects(ctx context.Context, jitRequest *justintimev1.JitRequest) error <span class="cov8" title="1">{
        for _, namespace := range jitRequest.Spec.Namespaces </span><span class="cov0" title="0">{
                roleBindings := &amp;rbacv1.RoleBindingList{}

                err := r.List(ctx, roleBindings, client.InNamespace(namespace))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, roleBinding := range roleBindings.Items </span><span class="cov0" title="0">{
                        for _, ownerRef := range roleBinding.OwnerReferences </span><span class="cov0" title="0">{
                                if ownerRef.Kind == "JitRequest" &amp;&amp; ownerRef.Name == jitRequest.Name </span><span class="cov0" title="0">{
                                        // Delete the RoleBinding if it is owned by the JitRequest
                                        if err := r.Delete(ctx, &amp;roleBinding); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Check and return true if something already exists
func isAlreadyExistsError(err error) bool <span class="cov0" title="0">{
        return err != nil &amp;&amp; apierrors.IsAlreadyExists(err)
}</span>

// Create rolebinding(s) for a JitRequest's namespaces
func (r *JitRequestReconciler) createRoleBinding(ctx context.Context, jitRequest *justintimev1.JitRequest) error <span class="cov8" title="1">{
        // Add reporter to subject
        subjects := []rbacv1.Subject{
                {
                        Kind: rbacv1.UserKind,
                        Name: jitRequest.Spec.Reporter,
                },
        }

        // Add additional user emails as subjects if defined
        for _, email := range jitRequest.Spec.AdditionUserEmails </span><span class="cov0" title="0">{
                subjects = append(subjects, rbacv1.Subject{
                        Kind: rbacv1.UserKind,
                        Name: email,
                })
        }</span>

        // Loop through namespaces in JitRequest and create role binding
        <span class="cov8" title="1">for _, namespace := range jitRequest.Spec.Namespaces </span><span class="cov8" title="1">{
                roleBinding := &amp;rbacv1.RoleBinding{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      fmt.Sprintf("%s-jit", jitRequest.Name),
                                Namespace: namespace,
                                Annotations: map[string]string{
                                        "justintime.samir.io/expiry": jitRequest.Spec.EndTime.Time.Format(time.RFC3339),
                                },
                        },
                        Subjects: subjects,
                        RoleRef: rbacv1.RoleRef{
                                APIGroup: rbacv1.GroupName,
                                Kind:     "ClusterRole",
                                Name:     jitRequest.Spec.ClusterRole,
                        },
                }

                // Set owner references
                if err := controllerutil.SetControllerReference(jitRequest, roleBinding, r.Scheme); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set owner reference for RoleBinding: %v", err)
                }</span>

                // Create RoleBinding
                <span class="cov8" title="1">if err := r.Client.Create(ctx, roleBinding); err != nil </span><span class="cov0" title="0">{
                        if !isAlreadyExistsError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create RoleBinding: %w", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Update JitRequest status and message with retry up to maxAttempts attempts
func (r *JitRequestReconciler) updateStatus(
        ctx context.Context,
        jitRequest *justintimev1.JitRequest,
        status,
        message,
        jiraTicket string,
        maxAttempts int,
) error <span class="cov8" title="1">{
        attempts := 0
        for </span><span class="cov8" title="1">{
                attempts++
                jitRequest.Status.State = status
                jitRequest.Status.Message = message
                jitRequest.Status.JiraTicket = jiraTicket
                err := r.Status().Update(ctx, jitRequest)
                if err == nil </span><span class="cov8" title="1">{
                        return nil // Update successful
                }</span>
                <span class="cov0" title="0">if apierrors.IsConflict(err) </span><span class="cov0" title="0">{
                        // Conflict error, retry the update
                        if attempts &gt;= maxAttempts </span><span class="cov0" title="0">{
                                return fmt.Errorf("maximum retry attempts reached, failed to update JitRequest status")
                        }</span>
                        // Incremental sleep between attempts
                        <span class="cov0" title="0">time.Sleep(time.Duration(attempts*2) * time.Second)
                        continue</span>
                }
                // Other error, return with the error
                <span class="cov0" title="0">return fmt.Errorf("failed to update JitRequest status: %v", err)</span>
        }
}

/*
Predicate function to filter events for JitRequest objects
Ignore StatusRejected update event for JitRequest if the same
*/
func jitRequestPredicate() predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                UpdateFunc: func(e event.UpdateEvent) bool </span><span class="cov8" title="1">{
                        oldJitRequest := e.ObjectOld.(*justintimev1.JitRequest)
                        newJitRequest := e.ObjectNew.(*justintimev1.JitRequest)

                        if oldJitRequest.Status.State == StatusRejected &amp;&amp;
                                newJitRequest.Status.State == StatusRejected </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov8" title="1">return newJitRequest.Status.State == StatusRejected</span>
                },
        }
}

// SetupWithManager sets up the controller with the Manager.
func (r *JitRequestReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;justintimev1.JitRequest{}, builder.WithPredicates(predicate.ResourceVersionChangedPredicate{}, jitRequestPredicate())).
                Named("jitrequest").
                Complete(r)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
